<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Giocode labs]]></title>
  <link href="http://giocode.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://giocode.github.io/"/>
  <updated>2015-08-01T17:22:07-07:00</updated>
  <id>http://giocode.github.io/</id>
  <author>
    <name><![CDATA[Rindra Ramamonjison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional Playground: Solving the Rush Hour Game in Haskell]]></title>
    <link href="http://giocode.github.io/blog/2014/10/16/functional-playground-solving-rush-hour-game-in-haskell/"/>
    <updated>2014-10-16T17:01:36-07:00</updated>
    <id>http://giocode.github.io/blog/2014/10/16/functional-playground-solving-rush-hour-game-in-haskell</id>
    <content type="html"><![CDATA[<p>{% img right /images/rushhour.png 250 250 %}
In this blog post, I will demonstrate the functional way of solving problems using the popular <a href="http://www.thinkfun.com/rushhour">Rush Hour</a> board game as an example. I will employ simple yet powerful language features that Haskell provides to produce expressive and modular programs, which are:</p>

<ul>
<li>Types and abstractions</li>
<li>Pattern matching and recursions</li>
<li>Higher-order functions and combinators</li>
<li>Function composition and currying</li>
</ul>


<h2>Rush Hour: the game</h2>

<p>The Rush Hour game consists of a traffic grid in which some cars and trucks are laid out. The goal is to find a path for the Red Car to exit by moving the other blocking vehicles out of its way. Created by Nob Yoshigahara in the 70&rsquo;s, this game has kept people entertained and puzzled with its several levels of difficulty.</p>

<!-- more -->


<p>In Rush Hour, each vehicle can move only in either horizontally or vertically. At the start, the Red Car is placed horizontally on the 3rd line from the top. The other cars and trucks are blocking Red Car&rsquo;s straight path to the Exit.</p>

<p>Now, let&rsquo;s see how functional programming can be of help to solve the Rush Hour puzzle.</p>

<h2>Game abstraction</h2>

<p>Thinking about the game, we can capture the locations and orientations of all vehicles at any instant as a state. Our objective is to find a state in which the Red Car is placed just in front of the Exit. Let&rsquo;s call such state a <em>goal state</em>. To that, we transition from the initial state to a goal state through a sequence of moves. In each move, we move a car in a specific direction. The move is valid if the new location of the car does not land off the grid and does not overlap with another car. Ok, that&rsquo;s enough English we can translate to Haskell. So let&rsquo;s create some data types and type synonyms to abstract the cars, the states and the moves.</p>

<p>{% codeblock lang:haskell %}
data Orientation = H | V deriving (Show, Eq)
data Direction = L | R | U | D deriving (Show)
data Car = Car {
                x :: Int,               &ndash; x-coordinate: from top-left corner of grid
                y :: Int,               &ndash; y-coordinate
                o :: Orientation,       &ndash; Vertical or Horizontal
                sz :: Int               &ndash; Car vs Truck
            } deriving (Show, Eq)     <br/>
type Line = String<br/>
type CarLetter = Char                   &ndash; Representation of vehicle
type State = Map CarLetter Car          &ndash; State of grid: Map with CarLetter/Car pairs
type Move = (CarLetter, Direction)<br/>
{% endcodeblock %}</p>

<p>Now, let&rsquo;s create some functions for moving cars. The first function <code>moveCar</code> takes a car and a direction to move and returns another car with the same orientation and size but at a new location.</p>

<p>{% codeblock lang:haskell %}
moveCar :: Car -> Direction -> Car
moveCar (Car xpos ypos H size) L = Car (xpos-1) ypos H size
moveCar (Car xpos ypos H size) R = Car (xpos+1) ypos H size
moveCar (Car xpos ypos V size) U = Car xpos (ypos-1) V size
moveCar (Car xpos ypos V size) D = Car xpos (ypos+1) V size
moveCar car _ = car
{% endcodeblock %}</p>

<p>The next function <code>move</code> takes a State and a Move then returns a new State.
{% codeblock lang:haskell %}
move :: State -> Move -> State
move state (key, dir) = Map.insert key newCar state where
    newCar :: Car
    newCar = moveCar (state ! key) dir
{% endcodeblock %}</p>

<p>In <code>move</code>, we assume that the Move is a valid one. To make sure we respect the rules of the game, we need two functions that tell us whether two cars are overlapping in the grid and whether a Car is off the grid.</p>

<p>{% codeblock lang:haskell %}
isOverlapping :: Car -> Car -> Bool
isOverlapping (Car x y H sz) (Car xnew ynew H sznew)
    | y /= ynew = False
    | y &lt; ynew &amp;&amp; y+sz-1 &lt; ynew = False
    | ynew &lt; y &amp;&amp; ynew+sznew-1 &lt; y = False
    | otherwise = True
isOverlapping (Car x y V sz) (Car xnew ynew V sznew)
    | x /= xnew = False
    | x &lt; xnew &amp;&amp; x+sz-1 &lt; xnew = False
    | xnew &lt; x &amp;&amp; xnew+sznew-1 &lt; x = False
    | otherwise = True
isOverlapping (Car x y H sz) (Car xnew ynew V sznew)
    | xnew &lt; x || xnew > x+sz-1 = False
    | ynew > y = False <br/>
    | ynew &lt; y &amp;&amp; ynew+sznew-1 &lt; y = False
    | otherwise = True
isOverlapping (Car x y V sz) (Car xnew ynew H sznew)
    | x &lt; xnew || x > xnew+sznew-1 = False
    | y > ynew = False <br/>
    | y &lt; ynew &amp;&amp; y+sz-1 &lt; ynew = False
    | otherwise = True</p>

<p>isOffgrid :: Car -> Bool
isOffgrid (Car x y H size)
    | x+size-1 > gridSize = True
    | x &lt; 1  = True
    | y &lt; 1 || y > gridSize = True
isOffgrid (Car x y V size)
    | y+size-1 > gridSize = True
    | y &lt; 1 = True
    | x &lt; 1 || x > gridSize = True
isOffgrid _ = False
{% endcodeblock %}</p>

<h2>State-Space search</h2>

<p>There are two ways to measure our ability to play the game. The first one is the number of moves that you make to exit the Red Car. The fewest moves you make, the more impressed your friends will be. The second one is the amount of time it takes to actually find the path to the exit. No matter how short the path you find, your friends will not be very impressed if you ask them to wait for hours. Since, we are going to cheat twice by using a computer and also Haskell, we will not be as much concerned about the amount of time to find a path. Instead, we will focus on finding the shortest path. So how are we going to tell Haskell to do that for us?</p>

<p>The mechanism to solve Rush Hour and other similar puzzles is <a href="http://en.wikipedia.org/wiki/State_space_search">State Space search</a>. At any instant of the game, we can actually imagine ourselves lost in an &ldquo;invisible&rdquo; directed graph where each node is a State and each edge is a Move. Two States <code>fromState</code> and <code>toState</code> are linked by a Move <code>move</code> whenever we can legally move a car in <code>fromState</code> and obtain the new state <code>toState</code>. Since we are interested to find the shortest path to exit, we&rsquo;ll use a depth-first approach.</p>

<p>Beginning with the end in mind, let&rsquo;s declare the function <code>statesearch</code>. It takes the following three inputs:</p>

<ol>
<li>An initial State</li>
<li>A list of States that have already been explored</li>
<li>A list of Paths to be explored</li>
</ol>


<p>Then, <code>statesearch</code> returns a Path to the exit as output. A path is simply a tuple composed of the current state and a list of moves that led to that state from the initial one.
{% codeblock lang:haskell %}
type Path = (State, [Move])           <br/>
{% endcodeblock %}</p>

<p>For clarity, let&rsquo;s give some meaningul names to the types of the last two inputs of <code>statesearch</code> as follows:</p>

<p>{% codeblock lang:haskell %}
type ExploredStates = [State]          <br/>
type UnexploredPaths = [Path]         <br/>
{% endcodeblock %}</p>

<p>In our state-space search, we also need a function <code>solved</code> that checks  if for a given state we have reached our goal. We assume that the key for the Red Car is the character <code>'X'</code>. So here, we just check if it is already in front of the exit.
{% codeblock lang:haskell %}
gridSize = 6
solved :: State -> Bool
solved state = (x xcar + sz xcar - 1 == gridSize) where
    xcar = state ! &lsquo;X&rsquo;
{% endcodeblock %}</p>

<p>Another helper function that will be useful in the state-space is <code>generateNewMoves</code>, which produces a list of possible move for each car in a given state and then concatenates all possible moves.</p>

<p>{% codeblock lang:haskell %}
generateNewMoves :: State -> [Move]
generateNewMoves state = concat $ map generateNew (Map.keys state) where
    generateNew :: CarLetter -> [Move]
    generateNew key
        | o (state ! key) == H  = [(key, L), (key,R)]
        | otherwise             = [(key, U), (key,D)]
{% endcodeblock %}</p>

<p>The generated moves do not have to be valid yet. We just make sure to generate moves that correspond to the orientation of each moved car. In other words, a horizontally oriented car cannot be moved up or down and vice versa. However, we will still need later to filter the valid moves.</p>

<h3>Our depth-first state-space search</h3>

<p>Now, let&rsquo;s present the state-space search with depth-first traversal strategy:</p>

<p>{% codeblock lang:haskell %}
statesearch :: ExploredStates -> UnexploredPaths -> Maybe Path
statesearch _ [] = Nothing
statesearch explored (p@(state, mvs) : paths)
    | solved state = Just p
    | state <code>elem</code> explored = statesearch explored paths
    | otherwise = statesearch
                    (state:explored)
                    (paths ++ nextPaths) where
                        nextPaths :: [Path]
                        nextPaths = [(move state m, mvs ++ [m]) | m &lt;- generateNewMoves state, isValid state m]
{% endcodeblock %}</p>

<p>To find a solution form a state <code>start</code>, we call the above function as follows:</p>

<p>{% codeblock lang:haskell %}
solve :: State -> Maybe Path
solve start = statesearch [] [(start,[])]
{% endcodeblock %}</p>

<p>In <code>solve</code>, we initialize the list of unexplored paths to <code>[(start,[])</code>. On the other hand, the list of explored states is initially empty.</p>

<p><code>statesearch</code> is implemented using pattern matching and recursion. The first thing it does is looking at the list of unexplored paths. If there is no more path to explore, the function returns <code>Nothing</code> which means there is no solution to the puzzle. Otherwise, we continue the search by evaluating the next path named <code>p@(state, mvs)</code> which is the head of the unexplored paths using the pattern matching:</p>

<p>{% codeblock lang:haskell %}
statesearch explored (p@(state, mvs) : paths)
{% endcodeblock %}</p>

<p>If the final <code>state</code> in the currently evaluated path is a <em>goal state</em>, then the function declares success by returning just that path <code>p</code>.</p>

<p>Next, let&rsquo;s look at what happens if we have not yet reached our goal. <code>statesearch</code> then checks whether the current <code>state</code> has already been explored before. In that case, the path or list of moves that led us to <code>state</code> is no good. So, we simply discard that path and move on to the next one otherwise we will fall into a cycle. This is done through the recursive call <code>statesearch explored paths</code>.</p>

<p>Now, suppose that the current <code>state</code> is not a <code>goal state</code> and it has not yet been explored. Then, we continue our search by generating some valid moves. For each valid move <code>m</code>, we produce an updated state <code>move state m</code> and an updated list of moves <code>mvs ++ [m]</code> and combine these into the current path <code>p</code>. We do that for each valid move and then we concatenate the generated paths to the list of path to be explored. Note that because we adopt a breadth-first search, we must append these paths at the end of the list. If we did otherwise, it is very unlikely that we would have found the shortest path to the exit.
After evaluating the previous state, we add it to the list of explored states and make the recursive call:</p>

<p>{% codeblock lang:haskell %}
statesearch (state:explored) (paths ++ nextPaths) where
    nextPaths :: [Path]
    nextPaths = [(move state m, mvs ++ [m]) | m &lt;- generateNewMoves state, isValid state m]
{% endcodeblock %}
So that&rsquo;s how elegant a state-space search can be implemented in Haskell. <code>statesearch</code> is the core function to solve the puzzle. The rest is a representation of the problem and helper functions.</p>

<h2>Time to play</h2>

<p>Well, before we can show some descent user-interface to this puzzle. We&rsquo;ll need helpers functions that converts a string representation of the grid to a State and vice versa. So, we define the following functions:
{% codeblock lang:haskell %}
type Line = String
stateToLines :: State -> [Line]
linesToState :: [Line] -> State
{% endcodeblock %}</p>

<p>Let&rsquo;s illustrate how these would work with an example without showing their implementations. Suppose our initial state prints like this:
{% codeblock%}
-A&mdash;-
-A&mdash;D
XXXC-D
&mdash;C-D</p>

<h2>-BBB&ndash;</h2>

<p>{% endcodeblock %}</p>

<p>Then, the function <code>linesToState</code> would return the following State when applied to the above <code>[Line]</code> representation:
{% codeblock lang:haskell %}
Map.fromList [(&lsquo;A&rsquo;,Car {x = 2, y = 1, o = V, sz = 2}),
                (&lsquo;B&rsquo;,Car {x = 2, y = 5, o = H, sz = 3}),
                (&lsquo;C&rsquo;,Car {x = 4, y = 3, o = V, sz = 2}),
                (&rsquo;D&#8217;,Car {x = 6, y = 2, o = V, sz = 3}),
                (&lsquo;X&rsquo;,Car {x = 1, y = 3, o = H, sz = 3})]
{% endcodeblock %}</p>

<p>Solving this <em>beginner level</em> puzzle with Haskell and your supercomputer would be a real overkill. But for the sake of fun, here is the output:</p>

<p>{% codeblock%}
-A&mdash;-
-A&mdash;D
XXXC-D
&mdash;C-D</p>

<h2>-BBB&ndash;</h2>

<p>-A&mdash;-
-A&mdash;D
XXXC-D
&mdash;C-D</p>

<h2>BBB&mdash;</h2>

<p>-A&mdash;-
-A&mdash;D
XXX&ndash;D
&mdash;C-D</p>

<h2>BBBC&ndash;</h2>

<p>-A&mdash;-
-A&mdash;-
XXX&ndash;D
&mdash;C-D</p>

<h2>BBBC-D</h2>

<p>-A&mdash;-
-A&mdash;-
XXX&mdash;
&mdash;C-D
BBBC-D
&mdash;&ndash;D</p>

<p>-A&mdash;-
-A&mdash;-
-XXX&ndash;
&mdash;C-D
BBBC-D
&mdash;&ndash;D</p>

<p>-A&mdash;-
-A&mdash;-
&ndash;XXX-
&mdash;C-D
BBBC-D
&mdash;&ndash;D</p>

<p>-A&mdash;-
-A&mdash;-
&mdash;XXX
&mdash;C-D
BBBC-D
&mdash;&ndash;D
{% endcodeblock %}</p>

<p>Yay! Now, try it with a super tough challenge.</p>

<p>{% if page.comments %}</p>

<div id="disqus_thread"></div>


<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'Rico'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<p><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></p>

<p>{% endif%}</p>
]]></content>
  </entry>
  
</feed>
