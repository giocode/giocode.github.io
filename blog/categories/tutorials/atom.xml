<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tutorials | Giocode labs]]></title>
  <link href="http://giocode.github.io/blog/categories/tutorials/atom.xml" rel="self"/>
  <link href="http://giocode.github.io/"/>
  <updated>2015-08-01T17:22:07-07:00</updated>
  <id>http://giocode.github.io/</id>
  <author>
    <name><![CDATA[Rindra Ramamonjison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional Playground: Solving the Rush Hour Game in Haskell]]></title>
    <link href="http://giocode.github.io/blog/2014/10/16/functional-playground-solving-rush-hour-game-in-haskell/"/>
    <updated>2014-10-16T17:01:36-07:00</updated>
    <id>http://giocode.github.io/blog/2014/10/16/functional-playground-solving-rush-hour-game-in-haskell</id>
    <content type="html"><![CDATA[<p>{% img right /images/rushhour.png 250 250 %}
In this blog post, I will demonstrate the functional way of solving problems using the popular <a href="http://www.thinkfun.com/rushhour">Rush Hour</a> board game as an example. I will employ simple yet powerful language features that Haskell provides to produce expressive and modular programs, which are:</p>

<ul>
<li>Types and abstractions</li>
<li>Pattern matching and recursions</li>
<li>Higher-order functions and combinators</li>
<li>Function composition and currying</li>
</ul>


<h2>Rush Hour: the game</h2>

<p>The Rush Hour game consists of a traffic grid in which some cars and trucks are laid out. The goal is to find a path for the Red Car to exit by moving the other blocking vehicles out of its way. Created by Nob Yoshigahara in the 70&rsquo;s, this game has kept people entertained and puzzled with its several levels of difficulty.</p>

<!-- more -->


<p>In Rush Hour, each vehicle can move only in either horizontally or vertically. At the start, the Red Car is placed horizontally on the 3rd line from the top. The other cars and trucks are blocking Red Car&rsquo;s straight path to the Exit.</p>

<p>Now, let&rsquo;s see how functional programming can be of help to solve the Rush Hour puzzle.</p>

<h2>Game abstraction</h2>

<p>Thinking about the game, we can capture the locations and orientations of all vehicles at any instant as a state. Our objective is to find a state in which the Red Car is placed just in front of the Exit. Let&rsquo;s call such state a <em>goal state</em>. To that, we transition from the initial state to a goal state through a sequence of moves. In each move, we move a car in a specific direction. The move is valid if the new location of the car does not land off the grid and does not overlap with another car. Ok, that&rsquo;s enough English we can translate to Haskell. So let&rsquo;s create some data types and type synonyms to abstract the cars, the states and the moves.</p>

<p>{% codeblock lang:haskell %}
data Orientation = H | V deriving (Show, Eq)
data Direction = L | R | U | D deriving (Show)
data Car = Car {
                x :: Int,               &ndash; x-coordinate: from top-left corner of grid
                y :: Int,               &ndash; y-coordinate
                o :: Orientation,       &ndash; Vertical or Horizontal
                sz :: Int               &ndash; Car vs Truck
            } deriving (Show, Eq)     <br/>
type Line = String<br/>
type CarLetter = Char                   &ndash; Representation of vehicle
type State = Map CarLetter Car          &ndash; State of grid: Map with CarLetter/Car pairs
type Move = (CarLetter, Direction)<br/>
{% endcodeblock %}</p>

<p>Now, let&rsquo;s create some functions for moving cars. The first function <code>moveCar</code> takes a car and a direction to move and returns another car with the same orientation and size but at a new location.</p>

<p>{% codeblock lang:haskell %}
moveCar :: Car -> Direction -> Car
moveCar (Car xpos ypos H size) L = Car (xpos-1) ypos H size
moveCar (Car xpos ypos H size) R = Car (xpos+1) ypos H size
moveCar (Car xpos ypos V size) U = Car xpos (ypos-1) V size
moveCar (Car xpos ypos V size) D = Car xpos (ypos+1) V size
moveCar car _ = car
{% endcodeblock %}</p>

<p>The next function <code>move</code> takes a State and a Move then returns a new State.
{% codeblock lang:haskell %}
move :: State -> Move -> State
move state (key, dir) = Map.insert key newCar state where
    newCar :: Car
    newCar = moveCar (state ! key) dir
{% endcodeblock %}</p>

<p>In <code>move</code>, we assume that the Move is a valid one. To make sure we respect the rules of the game, we need two functions that tell us whether two cars are overlapping in the grid and whether a Car is off the grid.</p>

<p>{% codeblock lang:haskell %}
isOverlapping :: Car -> Car -> Bool
isOverlapping (Car x y H sz) (Car xnew ynew H sznew)
    | y /= ynew = False
    | y &lt; ynew &amp;&amp; y+sz-1 &lt; ynew = False
    | ynew &lt; y &amp;&amp; ynew+sznew-1 &lt; y = False
    | otherwise = True
isOverlapping (Car x y V sz) (Car xnew ynew V sznew)
    | x /= xnew = False
    | x &lt; xnew &amp;&amp; x+sz-1 &lt; xnew = False
    | xnew &lt; x &amp;&amp; xnew+sznew-1 &lt; x = False
    | otherwise = True
isOverlapping (Car x y H sz) (Car xnew ynew V sznew)
    | xnew &lt; x || xnew > x+sz-1 = False
    | ynew > y = False <br/>
    | ynew &lt; y &amp;&amp; ynew+sznew-1 &lt; y = False
    | otherwise = True
isOverlapping (Car x y V sz) (Car xnew ynew H sznew)
    | x &lt; xnew || x > xnew+sznew-1 = False
    | y > ynew = False <br/>
    | y &lt; ynew &amp;&amp; y+sz-1 &lt; ynew = False
    | otherwise = True</p>

<p>isOffgrid :: Car -> Bool
isOffgrid (Car x y H size)
    | x+size-1 > gridSize = True
    | x &lt; 1  = True
    | y &lt; 1 || y > gridSize = True
isOffgrid (Car x y V size)
    | y+size-1 > gridSize = True
    | y &lt; 1 = True
    | x &lt; 1 || x > gridSize = True
isOffgrid _ = False
{% endcodeblock %}</p>

<h2>State-Space search</h2>

<p>There are two ways to measure our ability to play the game. The first one is the number of moves that you make to exit the Red Car. The fewest moves you make, the more impressed your friends will be. The second one is the amount of time it takes to actually find the path to the exit. No matter how short the path you find, your friends will not be very impressed if you ask them to wait for hours. Since, we are going to cheat twice by using a computer and also Haskell, we will not be as much concerned about the amount of time to find a path. Instead, we will focus on finding the shortest path. So how are we going to tell Haskell to do that for us?</p>

<p>The mechanism to solve Rush Hour and other similar puzzles is <a href="http://en.wikipedia.org/wiki/State_space_search">State Space search</a>. At any instant of the game, we can actually imagine ourselves lost in an &ldquo;invisible&rdquo; directed graph where each node is a State and each edge is a Move. Two States <code>fromState</code> and <code>toState</code> are linked by a Move <code>move</code> whenever we can legally move a car in <code>fromState</code> and obtain the new state <code>toState</code>. Since we are interested to find the shortest path to exit, we&rsquo;ll use a depth-first approach.</p>

<p>Beginning with the end in mind, let&rsquo;s declare the function <code>statesearch</code>. It takes the following three inputs:</p>

<ol>
<li>An initial State</li>
<li>A list of States that have already been explored</li>
<li>A list of Paths to be explored</li>
</ol>


<p>Then, <code>statesearch</code> returns a Path to the exit as output. A path is simply a tuple composed of the current state and a list of moves that led to that state from the initial one.
{% codeblock lang:haskell %}
type Path = (State, [Move])           <br/>
{% endcodeblock %}</p>

<p>For clarity, let&rsquo;s give some meaningul names to the types of the last two inputs of <code>statesearch</code> as follows:</p>

<p>{% codeblock lang:haskell %}
type ExploredStates = [State]          <br/>
type UnexploredPaths = [Path]         <br/>
{% endcodeblock %}</p>

<p>In our state-space search, we also need a function <code>solved</code> that checks  if for a given state we have reached our goal. We assume that the key for the Red Car is the character <code>'X'</code>. So here, we just check if it is already in front of the exit.
{% codeblock lang:haskell %}
gridSize = 6
solved :: State -> Bool
solved state = (x xcar + sz xcar - 1 == gridSize) where
    xcar = state ! &lsquo;X&rsquo;
{% endcodeblock %}</p>

<p>Another helper function that will be useful in the state-space is <code>generateNewMoves</code>, which produces a list of possible move for each car in a given state and then concatenates all possible moves.</p>

<p>{% codeblock lang:haskell %}
generateNewMoves :: State -> [Move]
generateNewMoves state = concat $ map generateNew (Map.keys state) where
    generateNew :: CarLetter -> [Move]
    generateNew key
        | o (state ! key) == H  = [(key, L), (key,R)]
        | otherwise             = [(key, U), (key,D)]
{% endcodeblock %}</p>

<p>The generated moves do not have to be valid yet. We just make sure to generate moves that correspond to the orientation of each moved car. In other words, a horizontally oriented car cannot be moved up or down and vice versa. However, we will still need later to filter the valid moves.</p>

<h3>Our depth-first state-space search</h3>

<p>Now, let&rsquo;s present the state-space search with depth-first traversal strategy:</p>

<p>{% codeblock lang:haskell %}
statesearch :: ExploredStates -> UnexploredPaths -> Maybe Path
statesearch _ [] = Nothing
statesearch explored (p@(state, mvs) : paths)
    | solved state = Just p
    | state <code>elem</code> explored = statesearch explored paths
    | otherwise = statesearch
                    (state:explored)
                    (paths ++ nextPaths) where
                        nextPaths :: [Path]
                        nextPaths = [(move state m, mvs ++ [m]) | m &lt;- generateNewMoves state, isValid state m]
{% endcodeblock %}</p>

<p>To find a solution form a state <code>start</code>, we call the above function as follows:</p>

<p>{% codeblock lang:haskell %}
solve :: State -> Maybe Path
solve start = statesearch [] [(start,[])]
{% endcodeblock %}</p>

<p>In <code>solve</code>, we initialize the list of unexplored paths to <code>[(start,[])</code>. On the other hand, the list of explored states is initially empty.</p>

<p><code>statesearch</code> is implemented using pattern matching and recursion. The first thing it does is looking at the list of unexplored paths. If there is no more path to explore, the function returns <code>Nothing</code> which means there is no solution to the puzzle. Otherwise, we continue the search by evaluating the next path named <code>p@(state, mvs)</code> which is the head of the unexplored paths using the pattern matching:</p>

<p>{% codeblock lang:haskell %}
statesearch explored (p@(state, mvs) : paths)
{% endcodeblock %}</p>

<p>If the final <code>state</code> in the currently evaluated path is a <em>goal state</em>, then the function declares success by returning just that path <code>p</code>.</p>

<p>Next, let&rsquo;s look at what happens if we have not yet reached our goal. <code>statesearch</code> then checks whether the current <code>state</code> has already been explored before. In that case, the path or list of moves that led us to <code>state</code> is no good. So, we simply discard that path and move on to the next one otherwise we will fall into a cycle. This is done through the recursive call <code>statesearch explored paths</code>.</p>

<p>Now, suppose that the current <code>state</code> is not a <code>goal state</code> and it has not yet been explored. Then, we continue our search by generating some valid moves. For each valid move <code>m</code>, we produce an updated state <code>move state m</code> and an updated list of moves <code>mvs ++ [m]</code> and combine these into the current path <code>p</code>. We do that for each valid move and then we concatenate the generated paths to the list of path to be explored. Note that because we adopt a breadth-first search, we must append these paths at the end of the list. If we did otherwise, it is very unlikely that we would have found the shortest path to the exit.
After evaluating the previous state, we add it to the list of explored states and make the recursive call:</p>

<p>{% codeblock lang:haskell %}
statesearch (state:explored) (paths ++ nextPaths) where
    nextPaths :: [Path]
    nextPaths = [(move state m, mvs ++ [m]) | m &lt;- generateNewMoves state, isValid state m]
{% endcodeblock %}
So that&rsquo;s how elegant a state-space search can be implemented in Haskell. <code>statesearch</code> is the core function to solve the puzzle. The rest is a representation of the problem and helper functions.</p>

<h2>Time to play</h2>

<p>Well, before we can show some descent user-interface to this puzzle. We&rsquo;ll need helpers functions that converts a string representation of the grid to a State and vice versa. So, we define the following functions:
{% codeblock lang:haskell %}
type Line = String
stateToLines :: State -> [Line]
linesToState :: [Line] -> State
{% endcodeblock %}</p>

<p>Let&rsquo;s illustrate how these would work with an example without showing their implementations. Suppose our initial state prints like this:
{% codeblock%}
-A&mdash;-
-A&mdash;D
XXXC-D
&mdash;C-D</p>

<h2>-BBB&ndash;</h2>

<p>{% endcodeblock %}</p>

<p>Then, the function <code>linesToState</code> would return the following State when applied to the above <code>[Line]</code> representation:
{% codeblock lang:haskell %}
Map.fromList [(&lsquo;A&rsquo;,Car {x = 2, y = 1, o = V, sz = 2}),
                (&lsquo;B&rsquo;,Car {x = 2, y = 5, o = H, sz = 3}),
                (&lsquo;C&rsquo;,Car {x = 4, y = 3, o = V, sz = 2}),
                (&rsquo;D&#8217;,Car {x = 6, y = 2, o = V, sz = 3}),
                (&lsquo;X&rsquo;,Car {x = 1, y = 3, o = H, sz = 3})]
{% endcodeblock %}</p>

<p>Solving this <em>beginner level</em> puzzle with Haskell and your supercomputer would be a real overkill. But for the sake of fun, here is the output:</p>

<p>{% codeblock%}
-A&mdash;-
-A&mdash;D
XXXC-D
&mdash;C-D</p>

<h2>-BBB&ndash;</h2>

<p>-A&mdash;-
-A&mdash;D
XXXC-D
&mdash;C-D</p>

<h2>BBB&mdash;</h2>

<p>-A&mdash;-
-A&mdash;D
XXX&ndash;D
&mdash;C-D</p>

<h2>BBBC&ndash;</h2>

<p>-A&mdash;-
-A&mdash;-
XXX&ndash;D
&mdash;C-D</p>

<h2>BBBC-D</h2>

<p>-A&mdash;-
-A&mdash;-
XXX&mdash;
&mdash;C-D
BBBC-D
&mdash;&ndash;D</p>

<p>-A&mdash;-
-A&mdash;-
-XXX&ndash;
&mdash;C-D
BBBC-D
&mdash;&ndash;D</p>

<p>-A&mdash;-
-A&mdash;-
&ndash;XXX-
&mdash;C-D
BBBC-D
&mdash;&ndash;D</p>

<p>-A&mdash;-
-A&mdash;-
&mdash;XXX
&mdash;C-D
BBBC-D
&mdash;&ndash;D
{% endcodeblock %}</p>

<p>Yay! Now, try it with a super tough challenge.</p>

<p>{% if page.comments %}</p>

<div id="disqus_thread"></div>


<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'Rico'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<p><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></p>

<p>{% endif%}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala Flavors: A Tasting Tour Part 1]]></title>
    <link href="http://giocode.github.io/blog/2014/10/15/scala-flavors-a-tasting-tour/"/>
    <updated>2014-10-15T17:50:32-07:00</updated>
    <id>http://giocode.github.io/blog/2014/10/15/scala-flavors-a-tasting-tour</id>
    <content type="html"><![CDATA[<p>This a is the first part on a series of tutorials on Scala&rsquo;s language features. This series are written for anyone who are new to Scala, knows its syntax a bit but are excited and scared at the same type by the bipolarity of this <code>beautiful</code> language. In this first part, we will cover two points:</p>

<ul>
<li>Scala&rsquo;s type system</li>
<li>Scala&rsquo;s purely object-oriented language features</li>
</ul>


<h2>Starting strong and safe</h2>

<p>Scala&rsquo;s type system is strong, static and safe. What does that mean?</p>

<h3>Values, variables and Types</h3>

<p>There are two possible ways to associate a name to a value or an expression. The first one is <code>val</code>, which is used to permanently bind a value to an indentifier. Once a val is set, its value can no longer be reassigned. In other words, vals are like constants.</p>

<p>{% codeblock lang:scala %}
scala> val y = 5.0
y: Double = 5.0
scala> val message = &ldquo;Holla scala&rdquo;
message: String = Holla scala
{% endcodeblock %}</p>

<p>Changing the content of <code>message</code> to <em>&ldquo;Bye scala&rdquo;</em> is not possible. Instead, it will generate a compilation error because of a reassignment to a val.</p>

<p>The second one is <code>var</code>. You use a var for variables. Unlike vals, the value that a <code>var</code> refers to can be changed or reassigned in the future. For example, the <code>numberOfRabbits</code> enrolled to your farming program will probably keep growing.</p>

<p>{% codeblock lang:scala %}
scala> var numberOfRabbits = 6
numberOfRabbits: Int = 10
scala> numberOfRabbits = numberOfRabbits * 4
numberOfRabbits: Int = 40
scala> numberOfRabbits = numberOfRabbits * 4
numberOfRabbits: Int = 160
{% endcodeblock %}</p>

<p>Once a var is declared, its type however cannot be modified. In other words, numberOfRabbits can only contain an integer. Reassigning a string to it will not compile.</p>

<p>{% codeblock lang:scala %}
numberOfRabbits = &ldquo;will not compile&rdquo;
// Expression of type String doesn&rsquo;t comform to expected type Int.
{% endcodeblock %}</p>

<p>We have not yet explained what these types are about. Since Scala is a statically typed language, any values and variables are initialized with their type and content. Looking at the REPL outputs above, we did not declare any type when defining <code>y</code>, <code>message</code> or <code>numberOfRabbits</code>. So how did Scala know? Well, Scala is smart enough to infer the type from the right hand side of the assignment. Scala understood that &ldquo;Holla scala&rdquo; is definitely a string whereas the decimal 5.0 looks like a Double.</p>

<p>In principle, a formal way to define vals and vars is like this.
{% codeblock lang:scala %}
// The right side must return a value of the declared type.
val identifier: type = expression
{% endcodeblock %}</p>

<p>In some situations, we want to declare vals and vars without giving them an initial value. In that case, the type declaration is mandatory. Otherwise, the rule of thumb is to omit the types when they can be readily inferred with a glimpse and to declare them to add clarity to your code.</p>

<p>{% codeblock lang:scala %}
val z: Boolean;  // Scala follows you
val w;          // Scala will cry out loud
{% endcodeblock %}</p>

<p>You must be still asking yourself why we need vals when we can use vars. Be patient as we will come back to this question when we will later discuss the choice between mutable and immutable data. For now, let&rsquo;s get our feet wet by reviewing some basic types and operators.</p>

<h3>Basic Scala types and operators</h3>

<p>There are 3 types of operators:</p>

<ul>
<li>binary operators which take two operands on their left and right sides</li>
<li>unary prefix operators which are applied to one operand on its right</li>
<li>unary postix operators which have one operand on its left</li>
</ul>


<p>Here are some examples of binary and unary operators for the basic numeric types.</p>

<p>{% codeblock lang:scala %}
// Binary operators
scala> 20 * 1.20
Double = 24.0</p>

<p>scala> 3 / 2
Int = 1</p>

<p>scala> val larger = 3 max 7
larger: Int = 7</p>

<p>scala> val remainder = 11 % 3
remainder: Int = 2</p>

<p>// A unary prefix operator
scala> val decimalNumber = - 102.876
Double = - 102.876</p>

<p>// A unary postfix operator
decimalNumber toInt
Int = - 102
{% endcodeblock %}</p>

<p>Similarly, logical operators on Boolean values can be either unary or binary.</p>

<p>{% codeblock lang:scala %}</p>

<p>scala> val veracity = true
veracity: Boolean = true</p>

<p>scala> var lie = ! veracity  // a prefix operator
lie: Boolean = false</p>

<p>scala> veracity &amp;&amp; lie
Boolean = false</p>

<p>scala> val halftruth = veracity || lie
halftruth: Boolean = true
{% endcodeblock %}</p>

<p>In the following, let&rsquo;s shed some lights on the real nature of values, types and operators in Scala. Ready? Unveil!</p>

<h2>Objects orient Scala&rsquo;s type system</h2>

<p>Behind the curtain, Scala is a purely object-oriented programming language. In fact, every value is an object of some type. Each type is represented by a class which serves as a blueprint for all values of that type. Moreover, every operation in Scala is a method call on some object.</p>

<p>{% blockquote %}
Types are classes. Values are objects. Operations are method calls.
{% endblockquote %}</p>

<p>Primitive types such as String and Double are wrapper classes for Java&rsquo;s primitive types. Let&rsquo;s look at some string concatenation examples to understand this.</p>

<p>{% codeblock lang:scala %}
//String concatenations
scala> &ldquo;apples&rdquo; + &ldquo; oranges&rdquo;
String =  apples oranges</p>

<p>scala> o * 3<br/>
String =  oranges  oranges  oranges</p>

<p>scala> 3 + &ldquo; oranges&rdquo;
3 oranges
{% endcodeblock %}</p>

<p>If Scala was not awesome, we would have to rewrite the above concatenations as formal method calls:</p>

<p>{% codeblock lang:scala%}
// More verbose concatenations
scala> &ldquo;apples&rdquo;.+(&ldquo; oranges&rdquo;)
scala> &ldquo;oranges&rdquo;.*(3)<br/>
scala> 3.+(&ldquo; oranges&rdquo;)
{% endcodeblock %}</p>

<p>Luckily, any methods with single parameters can be written in Scala as if they were built-in infix operators. Therefore, we can omit the <code>.</code> notation and the parentheses enclosing the single parameter. Instead, we add a space before and after the method name. The cool thing about that is the flexibility to name your binary operations in any way you want as long as the name is a valid identifier.</p>

<h3>Method overloading</h3>

<p>Since Scala is object-oriented, it supports method overloading so that different methods with the same name can be defined provided their signatures are different.</p>

<p>Looking at <code>"apples".+(" oranges")</code>, we see that the concatenation is performed by calling the method <code>+</code> defined on the String object <em>&ldquo;apples&rdquo;</em> with the string parameter <em>&ldquo; oranges&rdquo;</em>. What gets return is the new String object <em>&ldquo;apples oranges&rdquo;</em>. Furthermore, many other signatures exist for the same operator <code>+</code>.
When it comes to <code>"oranges".*(3)</code>, <code>*</code> is another method defined on String and it returns the <em>&ldquo;oranges&rdquo;</em> string concatenated 3 times. If you look at the Scala documentation for StringOps, you will find the signature of this method to be <code>def *(n: Int): String</code>.</p>

<p>Of course, Scala will complain if you call a method on one object and the method signature is not present in the class definition.
{% codeblock lang:scala%}
scala> &ldquo;apples&rdquo; * 3.0
error: def *(x: Double): String cannot be resolved on String object</p>

<p>scala> 3 * &ldquo;oranges&rdquo;
error: def *(s: String): String cannot be resolved on Int object
{% endcodeblock %}
The only exception to this rule is if an <em>implicit conversion</em> is defined for the corresponding type, then the method call can be forwarded to the converted type. But let&rsquo;s keep things simple for now and perhaps, we&rsquo;ll discuss about implicits later on.</p>

<h3>Create Abstract Data Types with Classes</h3>

<p>It is time to create your own types. Classes are used to abstract and parameterize data types that serve as building blocks for your Scala program.</p>

<p><strong> Class definition: </strong> you define a class using the <code>class</code> keyword followed by the class name and class parameters. Optionally, you can add statements and expressions in the class body delimited by a <code>{}</code> block to do one of the following:</p>

<ul>
<li>declare and initialize value and variable fields</li>
<li>define public methods</li>
<li>define private methods helper or nested classes</li>
<li>execute some code, e.g. I/O actions</li>
</ul>


<p>Let&rsquo;s look at a culinary example in which we first define a <em>Recipe</em> class.</p>

<p>{% codeblock lang:scala %}
class Recipe(n: String, s: Int = 1, instructions: List[String] = Nil) {
  // some val and var fiels declarations and initializations
  val name = n
  val serves = s</p>

<p>  var description: String = &ldquo;&rdquo;
  var ingredients: Map[String, (Double, String)] = _
}
{% endcodeblock %}</p>

<p><strong> Class constructor </strong> asks you to specify the parameters <code>s</code>, <code>n</code>, and <code>instructions</code> to create the <code>Recipe</code> objects. For example, you call the constructor method and pass the name, the number of serves and instruction list. As a result, you get a new <em>easyNoodleRecipe</em> object.
{% codeblock lang:scala %}
var easyNoodleRecipe = new Recipe(&ldquo;Hot Instant Noodle&rdquo;, 4, List(&ldquo;Boil water&rdquo;, &ldquo;Cook noodle&rdquo;, &ldquo;Serve&rdquo;))
{% endcodeblock %}</p>

<p>Scala also allows us to define default values for some of these parameters so that when we create <em>Recipe</em> objects that have these default values, we no longer need to specify the corresponding parameters when calling the constructor. Behind the scene, Scala simply generates additional constructors during compilation to support this.
For example, we specified a default value of 1 for <code>s</code> and a default empty list for <code>instructions</code> in the class definition. Therefore, we can create an <em>healthySaladRecipe</em> that serves 1 by passing only the other two parameters.</p>

<p>{% codeblock lang:scala %}
val healthySaladRecipe = new Recipe(&ldquo;Healthy green salad&rdquo;, instructions = List(&ldquo;Put greens in a bowl&rdquo;, &ldquo;Add dressing&rdquo;, &ldquo;Mix&rdquo;))
{% endcodeblock %}</p>

<p>Similarly, we can create a <em>lazyBurgerRecipe</em> that serves one and has an empty instruction by passing only one parameter, its name.
{% codeblock lang:scala %}
var lazyBurgerRecipe = new Recipe(&ldquo;Big Mac Burger&rdquo;)
{% endcodeblock %}</p>

<p><strong> Class parameters vs. Class fields: </strong> there is an important difference about the scope of class parameters and var/val fields. Class parameters are not publicly visible unless they are defined with the keyword <code>var</code> or <code>val</code>. In such cases, a getter and/or a setter is generated correspondingly. In contrast, a class field is always defined with one of these keywords. Thus, Scala makes them accessible publicly. Here are some simple rules about the accessibility and visibility of class parameters and fields:</p>

<ol>
<li><strong> Class parameters defined <em>without var/val</em> keyword: </strong> can only be read within the class body definition.</li>
<li><strong> Class parameters defined <em>with val</em>: </strong> a getter is created and the parameter <em>can be read</em> by a user of the class, by the object itself or by another instance of the same class.</li>
<li><strong> Class parameters defined <em>with var</em>: </strong> a getter and a setter are generated so the parameter <em>can be read and also reassigned</em> by a user of the class, by the object itself or by another instance of the same class.</li>
</ol>


<p><strong> Methods vs Functions </strong>
In Scala, methods and functions are defined in the same way using the syntax:
{% codeblock lang:scala %}
def methodName(parameter1: Type1, Parameter2: Type2, &hellip;): OutputType = {
    &hellip;
    result_expression
}
{% endcodeblock %}
The difference between methods and functions in Scala is similar to that of instance methods and static methods in Java. In Scala, methods are invoked on an object instance with some parameters and are defined inside the class constructor. On the other hand, functions are not invoked on any object; they are simply called with some inputs and return an output. Furthermore, there are two ways to define functions in Scala. First, functions are usually defined inside a singleton object module. If that object is a companion of a class with the same name, then we can make the analogy with static methods in Java. Second, functions can alternatively be defined on the go using functions literals and assigned to a <code>val</code>.</p>

<p>As previously mentionned, when a method is invoked in Scala with a single parameter, it can be interpreted as a binary operation. In fact, we can ommit the dot notation in that case when calling the method and replacing it with spaces between the object, the method name and the parameters. On the other hand, a parameterless method is usually written with a dot notation as if we access a field of the object on which we invoke the method. This programming style is known as <em>universal access principle</em>.</p>

<p>Let&rsquo;s define some examples by defining two methods in the class Recipe&rsquo;s constructor.
{% codeblock lang:scala %}
class Recipe(val n: String, val s: Int = 1, instructions: List[String] = Nil) {
  var description: String = &ldquo;&rdquo;
  var ingredients: Map[String, (Double, String)] = _</p>

<p>  // New methods
  def hasNuts: Boolean = ingredients.keys.toList contains &ldquo;nuts&rdquo;</p>

<p>  def serve(p: Int): Map[String, (Double, String)] = this.ingredients mapValues (v => (v.<em>1 * p, v.</em>2))
}
{% endcodeblock %}</p>

<p>Now, we can test this in the Scala shell. Let&rsquo;s go back to our <code>healthySaladRecipe</code> and add its ingredients.</p>

<p>{% codeblock lang:scala %}
scala> healthySaladRecipe.ingredients = List(&ldquo;Tomatoes&rdquo;,&ldquo;Cucumber&rdquo;,&ldquo;Dressing&rdquo;,&ldquo;Feta cheese&rdquo;) zip List((1.0,&ldquo;unit&rdquo;), (1.0,&ldquo;unit&rdquo;), (1.0,&ldquo;unit&rdquo;),(50.0,&ldquo;grams&rdquo;)) toMap
healthySaladRecipe.ingredients: Map[String,(Double, String)] = Map(Tomatoes -> (1.0,unit), Cucumber -> (1.0,unit), Dressing -> (1.0,unit), Feta cheese -> (50.0,grams))
{% endcodeblock %}</p>

<p>Remember that <code>healthySaladRecipe</code> was defined as a <code>val</code>. However, it had fields defined as <code>var</code> such as ingredients. That means that <code>healthySaladRecipe</code> has a mutable state. This is a key distinction that is important in Scala. Even though an object is bound to a val. It can still changes state even the class of that object has mutable state. Mutable state is definitely to be avoided if we follow the functional programming principles. Here, we simply use this as an example to show that there is a key difference between <code>var</code> vs. <code>var</code> and <code>mutability</code> vs. <code>immutability</code>. In the second part of this tutorial, we will get into more details on this matter.</p>

<blockquote><p>A <code>val</code> that is bound to an object cannot be reassigned to another object. But that does not imply that the object does not have a mutable state!</p></blockquote>

<p>In the above code, we created a map of ingredients from a list of ingredients and a list of quantity. To do that, we invoked the method <code>zip</code> which is defined in <code>scala.collection.immutable.List</code> on the first list and passed the second list as parameter. This is an example of method invocation as binary operator in Scala. Then, we used a parameterless method <code>toMap</code> which is invoked on a list of pairs to create a Map.</p>

<p>By default, any Recipe object will serve one person. Let&rsquo;s check this in the shell.
{% codeblock lang:scala %}
scala> healthySaladRecipe.serves
res: Int = 1
{% endcodeblock %}</p>

<p>So now, what if you invite two of your friends for lunch and you make a healthy salad for the three of you. Well, you can now invoke the <code>serve</code> method that we previously defined for that. What you will obtain is a new list of ingredients with the right quantity for each ingredient.
{% codeblock lang:scala %}
scala> healthySaladRecipe.serve(3)
res: Map[String,(Double, String)] = Map(Tomatoes -> (3.0,unit), Cucumber -> (3.0,unit), Dressing -> (3.0,unit), Feta cheese -> (150.0,grams))
{% endcodeblock %}</p>

<p>Let&rsquo;s look closely at the implementation of the <code>serve</code> method.
{% codeblock lang:scala %}
def serve(p: Int): Map[String, (Double, String)] = this.ingredients mapValues (v => (v.<em>1 * p, v.</em>2))
{% endcodeblock %}</p>

<p>We accessed the list of ingredients of <code>healthySaladRecipe</code> and invoked a method <code>mapValues</code> which is defined in <code>scala.collection.immutable.Map</code>. This method takes a function value as parameter and applies that function to each value of the element in the map ingredients. Above, we used a function literal, also called anonymous or lambda function, using scala&rsquo;s syntax:
{% codeblock lang:scala %}
v => (v.<em>1 * p, v.</em>2)
{% endcodeblock %}
This function literal takes as input <code>v</code>, which has a type of a two-element tuple <code>(Double, String)</code>. Then, it returns of a value of the same type but with the ingredient quantity scaled by the number of serving <code>p</code>. We did not to specify the type signature of the function since Scala could infer to type of <code>v</code> from the type of <code>this.ingredients</code>.</p>

<p>We have reached the end of the Part 1 of this tour on &ldquo;Scala flavors&rdquo;. In Part 2, we will revisit some Scala object-oriented features including <em>case classes</em> and <em>companion objects</em>. We&rsquo;ll also get a taste of <em>first-class functions</em> in Scala. Finally, we&rsquo;ll touch on immutability vs. mutability in Scala.</p>

<p>{% if page.comments %}</p>

<div id="disqus_thread"></div>


<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'Rico'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<p><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></p>

<p>{% endif%}</p>
]]></content>
  </entry>
  
</feed>
