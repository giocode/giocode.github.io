<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Puzzles | Giocode labs]]></title>
  <link href="http://giocode.github.io/blog/categories/puzzles/atom.xml" rel="self"/>
  <link href="http://giocode.github.io/"/>
  <updated>2014-10-20T12:27:10-07:00</updated>
  <id>http://giocode.github.io/</id>
  <author>
    <name><![CDATA[Rindra Ramamonjison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional Playground: Solving the Rush Hour Game in Haskell]]></title>
    <link href="http://giocode.github.io/blog/2014/10/16/functional-playground-solving-rush-hour-game-in-haskell/"/>
    <updated>2014-10-16T17:01:36-07:00</updated>
    <id>http://giocode.github.io/blog/2014/10/16/functional-playground-solving-rush-hour-game-in-haskell</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/rushhour.png" width="250" height="250">
In this blog post, I will demonstrate the functional way of solving problems using the popular <a href="http://www.thinkfun.com/rushhour">Rush Hour</a> board game as an example. I will employ simple yet powerful language features that Haskell provides to produce expressive and modular programs, which are:</p>

<ul>
<li>Types and abstractions</li>
<li>Pattern matching and recursions</li>
<li>Higher-order functions and combinators</li>
<li>Function composition and currying</li>
</ul>


<h2>Rush Hour: the game</h2>

<p>The Rush Hour game consists of a traffic grid in which some cars and trucks are laid out. The goal is to find a path for the Red Car to exit by moving the other blocking vehicles out of its way. Created by Nob Yoshigahara in the 70&rsquo;s, this game has kept people entertained and puzzled with its several levels of difficulty.</p>

<p>In Rush Hour, each vehicle can move only in either horizontally or vertically. At the start, the Red Car is placed horizontally on the 3rd line from the top. The other cars and trucks are blocking Red Car&rsquo;s straight path to the Exit.</p>

<p>Now, let&rsquo;s see how functional programming can be of help to solve the Rush Hour puzzle.</p>

<h2>Game abstraction</h2>

<p>Thinking about the game, we can capture the locations and orientations of all vehicles at any instant as a state. Our objective is to find a state in which the Red Car is placed just in front of the Exit. Let&rsquo;s call such state a <em>goal state</em>. To that, we transition from the initial state to a goal state through a sequence of moves. In each move, we move a car in a specific direction. The move is valid if the new location of the car does not land off the grid and does not overlap with another car. Ok, that&rsquo;s enough English we can translate to Haskell. So let&rsquo;s create some data types and type synonyms to abstract the cars, the states and the moves.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Orientation</span> <span class="ow">=</span> <span class="kt">H</span> <span class="o">|</span> <span class="kt">V</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Direction</span> <span class="ow">=</span> <span class="kt">L</span> <span class="o">|</span> <span class="kt">R</span> <span class="o">|</span> <span class="kt">U</span> <span class="o">|</span> <span class="kt">D</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">x</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span>               <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">x</span><span class="o">-</span><span class="n">coordinate</span><span class="kt">:</span> <span class="n">from</span> <span class="n">top</span><span class="o">-</span><span class="n">left</span> <span class="n">corner</span> <span class="kr">of</span> <span class="n">grid</span>
</span><span class='line'>                <span class="n">y</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span>               <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">y</span><span class="o">-</span><span class="n">coordinate</span>
</span><span class='line'>                <span class="n">o</span> <span class="ow">::</span> <span class="kt">Orientation</span><span class="p">,</span>       <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="kt">Vertical</span> <span class="n">or</span> <span class="kt">Horizontal</span>
</span><span class='line'>                <span class="n">sz</span> <span class="ow">::</span> <span class="kt">Int</span>               <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="kt">Car</span> <span class="n">vs</span> <span class="kt">Truck</span>
</span><span class='line'>            <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>     <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Line</span> <span class="ow">=</span> <span class="kt">String</span><span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">CarLetter</span> <span class="ow">=</span> <span class="kt">Char</span>                   <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="kt">Representation</span> <span class="kr">of</span> <span class="n">vehicle</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">State</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">CarLetter</span> <span class="kt">Car</span>          <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="kt">State</span> <span class="kr">of</span> <span class="n">grid</span><span class="kt">:</span> <span class="kt">Map</span> <span class="n">with</span> <span class="kt">CarLetter</span><span class="o">/</span><span class="kt">Car</span> <span class="n">pairs</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Move</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">CarLetter</span><span class="p">,</span> <span class="kt">Direction</span><span class="p">)</span><span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Now, let&rsquo;s create some functions for moving cars. The first function <code>moveCar</code> takes a car and a direction to move and returns another car with the same orientation and size but at a new location.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">moveCar</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">Direction</span> <span class="ow">-&gt;</span> <span class="kt">Car</span>
</span><span class='line'><span class="nf">moveCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xpos</span> <span class="n">ypos</span> <span class="kt">H</span> <span class="n">size</span><span class="p">)</span> <span class="kt">L</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">(</span><span class="n">xpos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ypos</span> <span class="kt">H</span> <span class="n">size</span>
</span><span class='line'><span class="nf">moveCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xpos</span> <span class="n">ypos</span> <span class="kt">H</span> <span class="n">size</span><span class="p">)</span> <span class="kt">R</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">(</span><span class="n">xpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">ypos</span> <span class="kt">H</span> <span class="n">size</span>
</span><span class='line'><span class="nf">moveCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xpos</span> <span class="n">ypos</span> <span class="kt">V</span> <span class="n">size</span><span class="p">)</span> <span class="kt">U</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="n">xpos</span> <span class="p">(</span><span class="n">ypos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kt">V</span> <span class="n">size</span>
</span><span class='line'><span class="nf">moveCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xpos</span> <span class="n">ypos</span> <span class="kt">V</span> <span class="n">size</span><span class="p">)</span> <span class="kt">D</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="n">xpos</span> <span class="p">(</span><span class="n">ypos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="kt">V</span> <span class="n">size</span>
</span><span class='line'><span class="nf">moveCar</span> <span class="n">car</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">car</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The next function <code>move</code> takes a State and a Move then returns a new State.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">move</span> <span class="ow">::</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Move</span> <span class="ow">-&gt;</span> <span class="kt">State</span>
</span><span class='line'><span class="nf">move</span> <span class="n">state</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">key</span> <span class="n">newCar</span> <span class="n">state</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">newCar</span> <span class="ow">::</span> <span class="kt">Car</span>
</span><span class='line'>    <span class="n">newCar</span> <span class="ow">=</span> <span class="n">moveCar</span> <span class="p">(</span><span class="n">state</span> <span class="o">!</span> <span class="n">key</span><span class="p">)</span> <span class="n">dir</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>In <code>move</code>, we assume that the Move is a valid one. To make sure we respect the rules of the game, we need two functions that tell us whether two cars are overlapping in the grid and whether a Car is off the grid.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">isOverlapping</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'><span class="nf">isOverlapping</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">H</span> <span class="n">sz</span><span class="p">)</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xnew</span> <span class="n">ynew</span> <span class="kt">H</span> <span class="n">sznew</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span> <span class="o">/=</span> <span class="n">ynew</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">ynew</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">y</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">ynew</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">ynew</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">ynew</span><span class="o">+</span><span class="n">sznew</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'><span class="nf">isOverlapping</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">V</span> <span class="n">sz</span><span class="p">)</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xnew</span> <span class="n">ynew</span> <span class="kt">V</span> <span class="n">sznew</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">xnew</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">xnew</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">x</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">xnew</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">xnew</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">xnew</span><span class="o">+</span><span class="n">sznew</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'><span class="nf">isOverlapping</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">H</span> <span class="n">sz</span><span class="p">)</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xnew</span> <span class="n">ynew</span> <span class="kt">V</span> <span class="n">sznew</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">xnew</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">x</span> <span class="o">||</span> <span class="n">xnew</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">ynew</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">ynew</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">ynew</span><span class="o">+</span><span class="n">sznew</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'><span class="nf">isOverlapping</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">V</span> <span class="n">sz</span><span class="p">)</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">xnew</span> <span class="n">ynew</span> <span class="kt">H</span> <span class="n">sznew</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">xnew</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">xnew</span><span class="o">+</span><span class="n">sznew</span><span class="o">-</span><span class="mi">1</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">ynew</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">ynew</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">y</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">ynew</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">True</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">isOffgrid</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'><span class="nf">isOffgrid</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">H</span> <span class="n">size</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">gridSize</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span>  <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">gridSize</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'><span class="nf">isOffgrid</span> <span class="p">(</span><span class="kt">Car</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">V</span> <span class="n">size</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">gridSize</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">gridSize</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'><span class="nf">isOffgrid</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>State-Space search</h2>

<p>There are two ways to measure our ability to play the game. The first one is the number of moves that you make to exit the Red Car. The fewest moves you make, the more impressed your friends will be. The second one is the amount of time it takes to actually find the path to the exit. No matter how short the path you find, your friends will not be very impressed if you ask them to wait for hours. Since, we are going to cheat twice by using a computer and also Haskell, we will not be as much concerned about the amount of time to find a path. Instead, we will focus on finding the shortest path. So how are we going to tell Haskell to do that for us?</p>

<p>The mechanism to solve Rush Hour and other similar puzzles is <a href="http://en.wikipedia.org/wiki/State_space_search">State Space search</a>. At any instant of the game, we can actually imagine ourselves lost in an &ldquo;invisible&rdquo; directed graph where each node is a State and each edge is a Move. Two States <code>fromState</code> and <code>toState</code> are linked by a Move <code>move</code> whenever we can legally move a car in <code>fromState</code> and obtain the new state <code>toState</code>. Since we are interested to find the shortest path to exit, we&rsquo;ll use a depth-first approach.</p>

<p>Beginning with the end in mind, let&rsquo;s declare the function <code>statesearch</code>. It takes the following three inputs:</p>

<ol>
<li>An initial State</li>
<li>A list of States that have already been explored</li>
<li>A list of Paths to be explored</li>
</ol>


<p>Then, <code>statesearch</code> returns a Path to the exit as output. A path is simply a tuple composed of the current state and a list of moves that led to that state from the initial one.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Path</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">State</span><span class="p">,</span> <span class="p">[</span><span class="kt">Move</span><span class="p">])</span>           <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>For clarity, let&rsquo;s give some meaningul names to the types of the last two inputs of <code>statesearch</code> as follows:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">ExploredStates</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">State</span><span class="p">]</span>          <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">UnexploredPaths</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span>         <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>In our state-space search, we also need a function <code>solved</code> that checks  if for a given state we have reached our goal. We assume that the key for the Red Car is the character <code>'X'</code>. So here, we just check if it is already in front of the exit.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">gridSize</span> <span class="ow">=</span> <span class="mi">6</span>
</span><span class='line'><span class="nf">solved</span> <span class="ow">::</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'><span class="nf">solved</span> <span class="n">state</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="n">xcar</span> <span class="o">+</span> <span class="n">sz</span> <span class="n">xcar</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">gridSize</span><span class="p">)</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">xcar</span> <span class="ow">=</span> <span class="n">state</span> <span class="o">!</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="kt">X</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Another helper function that will be useful in the state-space is <code>generateNewMoves</code>, which produces a list of possible move for each car in a given state and then concatenates all possible moves.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">generateNewMoves</span> <span class="ow">::</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Move</span><span class="p">]</span>
</span><span class='line'><span class="nf">generateNewMoves</span> <span class="n">state</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="n">generateNew</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">keys</span> <span class="n">state</span><span class="p">)</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">generateNew</span> <span class="ow">::</span> <span class="kt">CarLetter</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Move</span><span class="p">]</span>
</span><span class='line'>    <span class="n">generateNew</span> <span class="n">key</span>
</span><span class='line'>        <span class="o">|</span> <span class="n">o</span> <span class="p">(</span><span class="n">state</span> <span class="o">!</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="kt">H</span>  <span class="ow">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="kt">L</span><span class="p">),</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="kt">R</span><span class="p">)]</span>
</span><span class='line'>        <span class="o">|</span> <span class="n">otherwise</span>             <span class="ow">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="kt">U</span><span class="p">),</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="kt">D</span><span class="p">)]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The generated moves do not have to be valid yet. We just make sure to generate moves that correspond to the orientation of each moved car. In other words, a horizontally oriented car cannot be moved up or down and vice versa. However, we will still need later to filter the valid moves.</p>

<h3>Our depth-first state-space search</h3>

<p>Now, let&rsquo;s present the state-space search with depth-first traversal strategy:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">statesearch</span> <span class="ow">::</span> <span class="kt">ExploredStates</span> <span class="ow">-&gt;</span> <span class="kt">UnexploredPaths</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Path</span>
</span><span class='line'><span class="nf">statesearch</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</span><span class='line'><span class="nf">statesearch</span> <span class="n">explored</span> <span class="p">(</span><span class="n">p</span><span class="o">@</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mvs</span><span class="p">)</span> <span class="kt">:</span> <span class="n">paths</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">solved</span> <span class="n">state</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">p</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">state</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">elem</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="n">explored</span> <span class="ow">=</span> <span class="n">statesearch</span> <span class="n">explored</span> <span class="n">paths</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">statesearch</span>
</span><span class='line'>                    <span class="p">(</span><span class="n">state</span><span class="kt">:</span><span class="n">explored</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="n">paths</span> <span class="o">++</span> <span class="n">nextPaths</span><span class="p">)</span> <span class="kr">where</span>
</span><span class='line'>                        <span class="n">nextPaths</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span>
</span><span class='line'>                        <span class="n">nextPaths</span> <span class="ow">=</span> <span class="p">[(</span><span class="n">move</span> <span class="n">state</span> <span class="n">m</span><span class="p">,</span> <span class="n">mvs</span> <span class="o">++</span> <span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">|</span> <span class="n">m</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">generateNewMoves</span> <span class="n">state</span><span class="p">,</span> <span class="n">isValid</span> <span class="n">state</span> <span class="n">m</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>To find a solution form a state <code>start</code>, we call the above function as follows:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">solve</span> <span class="ow">::</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Path</span>
</span><span class='line'><span class="nf">solve</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">statesearch</span> <span class="kt">[]</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span><span class="kt">[]</span><span class="p">)]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>In <code>solve</code>, we initialize the list of unexplored paths to <code>[(start,[])</code>. On the other hand, the list of explored states is initially empty.</p>

<p><code>statesearch</code> is implemented using pattern matching and recursion. The first thing it does is looking at the list of unexplored paths. If there is no more path to explore, the function returns <code>Nothing</code> which means there is no solution to the puzzle. Otherwise, we continue the search by evaluating the next path named <code>p@(state, mvs)</code> which is the head of the unexplored paths using the pattern matching:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">statesearch</span> <span class="n">explored</span> <span class="p">(</span><span class="n">p</span><span class="o">@</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mvs</span><span class="p">)</span> <span class="kt">:</span> <span class="n">paths</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>If the final <code>state</code> in the currently evaluated path is a <em>goal state</em>, then the function declares success by returning just that path <code>p</code>.</p>

<p>Next, let&rsquo;s look at what happens if we have not yet reached our goal. <code>statesearch</code> then checks whether the current <code>state</code> has already been explored before. In that case, the path or list of moves that led us to <code>state</code> is no good. So, we simply discard that path and move on to the next one otherwise we will fall into a cycle. This is done through the recursive call <code>statesearch explored paths</code>.</p>

<p>Now, suppose that the current <code>state</code> is not a <code>goal state</code> and it has not yet been explored. Then, we continue our search by generating some valid moves. For each valid move <code>m</code>, we produce an updated state <code>move state m</code> and an updated list of moves <code>mvs ++ [m]</code> and combine these into the current path <code>p</code>. We do that for each valid move and then we concatenate the generated paths to the list of path to be explored. Note that because we adopt a breadth-first search, we must append these paths at the end of the list. If we did otherwise, it is very unlikely that we would have found the shortest path to the exit.
After evaluating the previous state, we add it to the list of explored states and make the recursive call:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">statesearch</span> <span class="p">(</span><span class="n">state</span><span class="kt">:</span><span class="n">explored</span><span class="p">)</span> <span class="p">(</span><span class="n">paths</span> <span class="o">++</span> <span class="n">nextPaths</span><span class="p">)</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">nextPaths</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span>
</span><span class='line'>    <span class="n">nextPaths</span> <span class="ow">=</span> <span class="p">[(</span><span class="n">move</span> <span class="n">state</span> <span class="n">m</span><span class="p">,</span> <span class="n">mvs</span> <span class="o">++</span> <span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">|</span> <span class="n">m</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">generateNewMoves</span> <span class="n">state</span><span class="p">,</span> <span class="n">isValid</span> <span class="n">state</span> <span class="n">m</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>
So that&rsquo;s how elegant a state-space search can be implemented in Haskell. <code>statesearch</code> is the core function to solve the puzzle. The rest is a representation of the problem and helper functions.</p>

<h2>Time to play</h2>

<p>Well, before we can show some descent user-interface to this puzzle. We&rsquo;ll need helpers functions that converts a string representation of the grid to a State and vice versa. So, we define the following functions:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Line</span> <span class="ow">=</span> <span class="kt">String</span>
</span><span class='line'><span class="nf">stateToLines</span> <span class="ow">::</span> <span class="kt">State</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Line</span><span class="p">]</span>
</span><span class='line'><span class="nf">linesToState</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Line</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">State</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Let&rsquo;s illustrate how these would work with an example without showing their implementations. Suppose our initial state prints like this:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-A&mdash;-
</span><span class='line'>-A&mdash;D
</span><span class='line'>XXXC-D
</span><span class='line'>&mdash;C-D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2>-BBB&ndash;&lt;/h2>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Then, the function <code>linesToState</code> would return the following State when applied to the above <code>[Line]</code> representation:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="kt">A</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span><span class="kt">Car</span> <span class="p">{</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">o</span> <span class="ow">=</span> <span class="kt">V</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">}),</span>
</span><span class='line'>                <span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="kt">B</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span><span class="kt">Car</span> <span class="p">{</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">o</span> <span class="ow">=</span> <span class="kt">H</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}),</span>
</span><span class='line'>                <span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="kt">C</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span><span class="kt">Car</span> <span class="p">{</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">o</span> <span class="ow">=</span> <span class="kt">V</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">}),</span>
</span><span class='line'>                <span class="p">(</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="kt">D&#39;</span><span class="p">,</span><span class="kt">Car</span> <span class="p">{</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">o</span> <span class="ow">=</span> <span class="kt">V</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}),</span>
</span><span class='line'>                <span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="kt">X</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span><span class="kt">Car</span> <span class="p">{</span><span class="n">x</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">o</span> <span class="ow">=</span> <span class="kt">H</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">})]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Solving this <em>beginner level</em> puzzle with Haskell and your supercomputer would be a real overkill. But for the sake of fun, here is the output:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-A&mdash;-
</span><span class='line'>-A&mdash;D
</span><span class='line'>XXXC-D
</span><span class='line'>&mdash;C-D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2>-BBB&ndash;&lt;/h2>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;D
</span><span class='line'>XXXC-D
</span><span class='line'>&mdash;C-D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2>BBB&mdash;&lt;/h2>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;D
</span><span class='line'>XXX&ndash;D
</span><span class='line'>&mdash;C-D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2>BBBC&ndash;&lt;/h2>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;-
</span><span class='line'>XXX&ndash;D
</span><span class='line'>&mdash;C-D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2>BBBC-D&lt;/h2>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;-
</span><span class='line'>XXX&mdash;
</span><span class='line'>&mdash;C-D
</span><span class='line'>BBBC-D
</span><span class='line'>&mdash;&ndash;D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;-
</span><span class='line'>-XXX&ndash;
</span><span class='line'>&mdash;C-D
</span><span class='line'>BBBC-D
</span><span class='line'>&mdash;&ndash;D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;-
</span><span class='line'>&ndash;XXX-
</span><span class='line'>&mdash;C-D
</span><span class='line'>BBBC-D
</span><span class='line'>&mdash;&ndash;D&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>-A&mdash;-
</span><span class='line'>-A&mdash;-
</span><span class='line'>&mdash;XXX
</span><span class='line'>&mdash;C-D
</span><span class='line'>BBBC-D
</span><span class='line'>&mdash;&ndash;D</span></code></pre></td></tr></table></div></figure></p>

<p>Yay! Now, try it with a super tough challenge.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
